
B) Auth Flow (server)
- In login controller/service:
1) After verifying email + password, check `force_password_change`.
2) If true, issue a JWT/session token with limited scope (`mustChangePassword: true`).
3) Return flag `forcePasswordChange=true` in the response.

C) Client (crm_ui / client)
- In auth context or login response handler:
- If `forcePasswordChange` is true:
  - Redirect user immediately to `/change-password`.
  - Prevent navigation to other pages until password is updated.

D) Change Password Page
- Reuse existing design system (same Input, Button, Card, Typography).
- Add validation: 
- Minimum 10 chars, uppercase, lowercase, digit, special char.
- Must not equal the old password.
- On submit:
- POST to `/auth/change-password`.
- Server updates `password_hash` and sets `force_password_change=false`.

E) Server endpoint: POST /auth/change-password
- Authenticated endpoint (JWT must be valid, even if limited).
- Requires `currentPassword` and `newPassword`.
- Steps:
1) Verify current password.
2) Validate new password against policy.
3) Hash new password with argon2.
4) Update `users.password_hash` and `users.force_password_change=false`.
5) Return success.

F) UX safeguards
- Show non-intrusive message: "You must change your password to continue" on the Change Password page.
- Do NOT change any branding or styling — use current Card/Input/Button.
- Disable other routes until password is changed.

G) Acceptance Criteria
1) New admins created with `force_password_change=true` cannot access normal pages — they are forced to `/change-password`.
2) After successful change, flag resets to false; user can access full app.
3) Password validation enforced both client + server.
4) No visual drift. UI uses existing design system components.
5) All flows covered by simple tests (unit/integration).

Edge Cases:
- Wrong current password → show validation error (same Input error style).
- Weak new password → block and show error.
- API/DB error → show toast/notification using existing system.

Implement now.
